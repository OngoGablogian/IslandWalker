--- engine/battle/core.asm
+++ engine/battle/core.asm
@@ -6703,56 +6703,59 @@ LoadEnemyMon:
 	predef FillPP
 	jr .Finish
 
 .TrainerPP:
 ; Copy PP from the party struct
 	ld hl, wOTPartyMon1PP
 	ld a, [wCurPartyMon]
 	call GetPartyLocation
 	ld de, wEnemyMonPP
 	ld bc, NUM_MOVES
 	rst CopyBytes
 
 .Finish:
 ; Copy the first five base stats (the enemy mon's base Sp. Atk
 ; is also used to calculate Sp. Def stat experience)
 	ld hl, wBaseStats
 	ld de, wEnemyMonBaseStats
 	ld b, NUM_STATS - 1
 .loop
 	ld a, [hli]
 	ld [de], a
 	inc de
 	dec b
 	jr nz, .loop
 
-	ld a, [wBaseCatchRate]
-	ld [de], a
-	inc de
+        ld a, [wBaseCatchRate]
+        ld [de], a
+        inc de
 
-	ld a, [wBaseExp]
-	ld [de], a
+        ld a, [wBaseExp]
+        ld [de], a
+        inc de
+        ld a, [wBaseExp + 1]
+        ld [de], a
 
 	ld a, [wTempEnemyMonSpecies]
 	ld [wNamedObjectIndex], a
 
 	call GetPokemonName
 
 ; Did we catch it?
 	ld a, [wBattleMode]
 	and a
 	ret z
 
 ; Update enemy nickname
 	ld hl, wStringBuffer1
 	ld de, wEnemyMonNickname
 	ld bc, MON_NAME_LENGTH
 	rst CopyBytes
 
 ; Saw this mon
 	ld a, [wTempEnemyMonSpecies]
 	call SetSeenMon
 
 	ld hl, wEnemyMonStats
 	ld de, wEnemyStats
 	ld bc, NUM_BATTLE_STATS * 2
 	rst CopyBytes
@@ -7370,92 +7373,96 @@ GiveExperiencePoints:
 	dec c
 	jr z, .evs_done
 ; Use the second byte for Sp.Atk and Sp.Def
 	ld a, c
 	cp 2 ; two stats left, Sp.Atk and Sp.Def
 	jr nz, .ev_loop
 	ld a, [wBaseSpAtkSpDefEVs]
 	ld b, a
 	jr .ev_loop
 .evs_done
         ; Stop experience gain at level cap or MAX_LEVEL
         pop de
         push de
         ld hl, MON_LEVEL
         add hl, de
         ld a, [wLevelCap]
         ld b, a
         ld a, [hl]
         cp b
         jr c, .give_exp
         pop bc
         jmp .next_mon
 .give_exp
         xor a
         ldh [hMultiplicand + 0], a
+        ld a, [wEnemyMonBaseExp + 1]
         ldh [hMultiplicand + 1], a
         ld a, [wEnemyMonBaseExp]
         ldh [hMultiplicand + 2], a
         ld a, [wEnemyMonLevel]
         ldh [hMultiplier], a
         call Multiply
-        ld a, 7
+        ld a, 5
         ldh [hDivisor], a
         ld b, 4
         call Divide
 ; Boost Experience for traded Pokemon
         pop bc
 	ld hl, MON_OT_ID
 	add hl, bc
 	ld a, [wPlayerID]
 	cp [hl]
 	jr nz, .boosted
 	inc hl
 	ld a, [wPlayerID + 1]
 	cp [hl]
 	ld a, 0 ; no-optimize a = 0
 	jr z, .no_boost
 
 .boosted
 	call BoostExp
 	ld a, 1
 
 .no_boost
 ; Boost experience for a Trainer Battle
 	ld [wStringBuffer2 + 2], a
 	ld a, [wBattleMode]
 	dec a
 	call nz, BoostExp
 ; Boost experience for Lucky Egg
 	push bc
 	ld a, MON_ITEM
 	call GetPartyParamLocation
-	ld a, [hl]
-	call GetItemIndexFromID
-	cphl16 LUCKY_EGG
-	call z, BoostExp
-	ldh a, [hQuotient + 3]
+        ld a, [hl]
+        call GetItemIndexFromID
+        cphl16 LUCKY_EGG
+        call z, BoostExp
+
+        call ScaleExpByLevel
+
+        ldh a, [hQuotient + 3]
 	ld [wStringBuffer2 + 1], a
 	ldh a, [hQuotient + 2]
 	ld [wStringBuffer2], a
 	call GetCurNickname
 	ld hl, Text_MonGainedExpPoint
 	call BattleTextbox
 	ld a, [wStringBuffer2 + 1]
 	ldh [hQuotient + 3], a
 	ld a, [wStringBuffer2]
 	ldh [hQuotient + 2], a
 	pop bc
 	call AnimateExpBar
 	push bc
 	call LoadTilemapToTempTilemap
 	pop bc
 	ld hl, MON_EXP + 2
 	add hl, bc
 	ld d, [hl]
 	ldh a, [hQuotient + 3]
 	add d
 	ld [hld], a
 	ld d, [hl]
 	ldh a, [hQuotient + 2]
 	adc d
 	ld [hl], a
@@ -7678,63 +7685,144 @@ GiveExperiencePoints:
 	ld a, MON_SPECIES
 	call GetPartyParamLocation
 	ld b, h
 	ld c, l
 	jmp .loop
 
 .done
 	jmp ResetBattleParticipants
 
 .EvenlyDivideExpAmongParticipants:
 ; count number of battle participants
 	ld a, [wBattleParticipantsNotFainted]
 	ld b, a
 	ld c, PARTY_LENGTH
 	ld d, 0
 .count_loop
 	xor a
 	srl b
 	adc d
 	ld d, a
 	dec c
 	jr nz, .count_loop
 	cp 2
 	ret c
 
-	ld [wTempByteValue], a
-	ld hl, wEnemyMonBaseExp
-	xor a
-	ldh [hDividend + 0], a
-	ld a, [hl]
-	ldh [hDividend + 1], a
-	ld a, [wTempByteValue]
-	ldh [hDivisor], a
-	ld b, 2
-	call Divide
-	ldh a, [hQuotient + 3]
-	ld [hl], a
-	ret
+        ld [wTempByteValue], a
+        ld hl, wEnemyMonBaseExp
+        ld a, [hli]
+        ldh [hDividend + 2], a
+        ld a, [hl]
+        ldh [hDividend + 1], a
+        xor a
+        ldh [hDividend + 0], a
+        ld a, [wTempByteValue]
+        ldh [hDivisor], a
+        ld b, 3
+        call Divide
+        ldh a, [hQuotient + 3]
+        ld [wEnemyMonBaseExp], a
+        ldh a, [hQuotient + 2]
+        ld [wEnemyMonBaseExp + 1], a
+        ret
+
+ScaleExpByLevel:
+; Scale experience based on level difference
+        push bc
+
+        ; Get levels
+        ld hl, MON_LEVEL
+        add hl, bc          ; bc points to party mon
+        ld c, [hl]          ; c = player level (N)
+        ld a, [wEnemyMonLevel]
+        ld b, a             ; b = enemy level (L)
+
+        ; Level multiplier (d = 2L + 10)
+        add a
+        add 10
+        ld d, a
+
+        ; Level divider (e = L + N + 10)
+        ld a, b
+        add c
+        add 10
+        ld e, a
+
+        call .ScaleMod
+        call .ScaleMod
+        ld a, d
+        call .GetSqrt
+        ld d, a
+        ld a, e
+        call .GetSqrt
+        ld e, a
+        call .ScaleMod
+
+        ; +1 to final quotient
+        ld hl, hQuotient + 3
+        inc [hl]
+        jr nz, .done
+        dec hl
+        inc [hl]
+        jr nz, .done
+        dec hl
+        inc [hl]
+        jr nz, .done
+        dec hl
+        inc [hl]
+.done
+        pop bc
+        ret
+
+.ScaleMod:
+        ld a, d
+        ldh [hMultiplier], a
+        call Multiply
+        ld a, e
+        ldh [hDivisor], a
+        ld b, 4
+        jmp Divide
+
+.GetSqrt:
+        push bc
+        cp 225
+        ld c, 15
+        jr nc, .got_result
+        ld b, a
+        ld c, 0
+.squareloop
+        inc c
+        ld a, c
+        call SimpleMultiply
+        cp b
+        jr c, .squareloop
+        jr z, .got_result
+        dec c
+.got_result
+        ld a, c
+        pop bc
+        ret
 
 IsEvsGreaterThan510:
 ; Total EVs in bc. Set Carry flag if bc > 510.
 	ld a, HIGH(MAX_TOTAL_EV)
 	cp b
 	ret nz
 	ld a, LOW(MAX_TOTAL_EV)
 	cp c
 	ret
 
 BoostExp:
 ; Multiply experience by 1.5x
 	push bc
 ; load experience value
 	ldh a, [hProduct + 2]
 	ld b, a
 	ldh a, [hProduct + 3]
 	ld c, a
 ; halve it
 	srl b
 	rr c
 ; add it back to the whole exp value
 	add c
 	ldh [hProduct + 3], a
 	ldh a, [hProduct + 2]
